<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Web服务 | Corejs Doc</title>
    <meta name="generator" content="VuePress 1.4.1">
    <link rel="icon" href="/images/logo.png">
    <meta name="description" content="Node-Corejs文档">
    <link rel="preload" href="/assets/css/0.styles.21d739ca.css" as="style"><link rel="preload" href="/assets/js/app.3dfa1ee5.js" as="script"><link rel="preload" href="/assets/js/2.6fef8c05.js" as="script"><link rel="preload" href="/assets/js/20.9002e28b.js" as="script"><link rel="prefetch" href="/assets/js/10.b204632a.js"><link rel="prefetch" href="/assets/js/11.56c9accf.js"><link rel="prefetch" href="/assets/js/12.75ea1064.js"><link rel="prefetch" href="/assets/js/13.6182130e.js"><link rel="prefetch" href="/assets/js/14.10b2dc1a.js"><link rel="prefetch" href="/assets/js/15.104771fa.js"><link rel="prefetch" href="/assets/js/16.d73b1721.js"><link rel="prefetch" href="/assets/js/17.125936a0.js"><link rel="prefetch" href="/assets/js/18.cc2998e3.js"><link rel="prefetch" href="/assets/js/19.9d534a93.js"><link rel="prefetch" href="/assets/js/21.b596d1ee.js"><link rel="prefetch" href="/assets/js/3.78a772bd.js"><link rel="prefetch" href="/assets/js/4.3731c432.js"><link rel="prefetch" href="/assets/js/5.92ea34d1.js"><link rel="prefetch" href="/assets/js/6.d5dbca58.js"><link rel="prefetch" href="/assets/js/7.7184b924.js"><link rel="prefetch" href="/assets/js/8.ca7eb9f5.js"><link rel="prefetch" href="/assets/js/9.5d8d2bd5.js">
    <link rel="stylesheet" href="/assets/css/0.styles.21d739ca.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/images/logo.png" alt="Corejs Doc" class="logo"> <span class="site-name can-hide">Corejs Doc</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/guide/" class="nav-link router-link-active">
  教程
</a></div><div class="nav-item"><a href="/api/" class="nav-link">
  API
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/guide/" class="nav-link router-link-active">
  教程
</a></div><div class="nav-item"><a href="/api/" class="nav-link">
  API
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/guide/" class="sidebar-link">介绍</a></li><li><a href="/guide/getting-started.html" class="sidebar-link">快速上手</a></li><li><a href="/guide/web-service.html" class="active sidebar-link">Web服务</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/guide/web-service.html#启动web服务" class="sidebar-link">启动Web服务</a></li><li class="sidebar-sub-header"><a href="/guide/web-service.html#设置请求路径" class="sidebar-link">设置请求路径</a></li><li class="sidebar-sub-header"><a href="/guide/web-service.html#构建过程" class="sidebar-link">构建过程</a></li><li class="sidebar-sub-header"><a href="/guide/web-service.html#tls-ssl" class="sidebar-link">TLS/SSL</a></li><li class="sidebar-sub-header"><a href="/guide/web-service.html#处理模型" class="sidebar-link">处理模型</a></li><li class="sidebar-sub-header"><a href="/guide/web-service.html#全局拦截器" class="sidebar-link">全局拦截器</a></li><li class="sidebar-sub-header"><a href="/guide/web-service.html#全局中间件" class="sidebar-link">全局中间件</a></li><li class="sidebar-sub-header"><a href="/guide/web-service.html#错误拦截器" class="sidebar-link">错误拦截器</a></li><li class="sidebar-sub-header"><a href="/guide/web-service.html#日志收集" class="sidebar-link">日志收集</a></li></ul></li><li><a href="/guide/request-handler.html" class="sidebar-link">请求处理</a></li><li><a href="/guide/log-collectting.html" class="sidebar-link">日志收集</a></li><li><a href="/guide/logger-introduce.html" class="sidebar-link">日志输出器</a></li><li><a href="/guide/logger-group-introduce.html" class="sidebar-link">日志输出组</a></li><li><a href="/guide/cluster-manager.html" class="sidebar-link">多进程架构</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>进阶</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/guide/handler-manager.html" class="sidebar-link">Handler管理</a></li><li><a href="/guide/dynamic-middleware.html" class="sidebar-link">动态中间件</a></li><li><a href="/guide/static-resource.html" class="sidebar-link">静态资源</a></li><li><a href="/guide/logger-customizing.html" class="sidebar-link">自定义输出器</a></li><li><a href="/guide/logger-group-customizing.html" class="sidebar-link">自定义输出组</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="web服务"><a href="#web服务" class="header-anchor">#</a> Web服务</h1> <h2 id="启动web服务"><a href="#启动web服务" class="header-anchor">#</a> 启动Web服务</h2> <p>我们使用Corejs内置的<strong>ServiceCore</strong>创建和管理<strong>Web服务</strong>。启动<strong>Web服务</strong>分为两个步骤：</p> <p><strong>首先，使用<code>Core.ServiceCore</code>创建ServiceCore实例：</strong></p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> Core <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'node-corejs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> serviceCore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Core<span class="token punctuation">.</span>ServiceCore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>创建<strong>ServiceCore</strong>时可以指定<strong>Web服务</strong>的配置对象<code>configs</code>：</p> <ul><li><p><strong><code>configs.id</code></strong>：<strong>ServiceCore</strong>的ID，用于标识<strong>ServiceCore</strong>。非必填项，默认值：<code>ServiceCore_${generateRandomString(6, 'uln')}</code>;</p></li> <li><p><strong><code>configs.port</code></strong>：<strong>Web服务</strong>驻留的端口。非必填项，默认值：<code>3000</code>。</p></li> <li><p><strong><code>configs.serverOpt</code></strong>：<strong>Web服务</strong>的构建配置。非必填项，默认值：<code>{}</code>。</p></li> <li><p><strong><code>configs.baseRoutePath</code></strong>：<strong>Web服务</strong>的基础请求路径，用于指定统一的请求路径前缀。非必填项，默认值：<code>'/'</code>。</p> <blockquote><p><strong>比如，当此配置指定为<code>'/api'</code>，且ServiceCore挂载了请求路径规则为<code>'/Test.do'</code>的Handler时，客户端需要请求<code>'/api/Test.do'</code>才能命中此Handler。</strong></p></blockquote> <div class="custom-block warning"><p class="custom-block-title">注意</p> <p><strong>ServiceCore将自动校正配置对象中指定的基础请求路径：</strong></p> <ul><li><p><strong>当基础请求路径不以<code>'/'</code>开头时，将附加<code>'/'</code>作为前缀</strong>。比如：当业务层指定<strong>基础请求路径</strong>为<code>'api'</code>时将自动被校正为<code>'/api'</code>。</p></li> <li><p><strong>当基础请求路径以<code>'/'</code>结尾时，将删除位于结尾的所有<code>'/'</code></strong>。比如：当业务层指定<strong>基础请求路径</strong>为<code>'/api//'</code>时将自动被校正为<code>'/api'</code>。</p></li></ul></div></li> <li><p><strong><code>configs.middlewares</code></strong>：全局中间件列表。非必填项，默认值：<code>[]</code>。</p></li></ul> <hr> <p><strong>然后，使用实例方法<code>start()</code>启动Web服务</strong>。此方法接收两个非必填参数：<strong>启动配置</strong>和<strong>回调函数</strong>。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>serviceCore<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span>options<span class="token punctuation">]</span><span class="token punctuation">,</span> callBack<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><div class="custom-block tip"><p class="custom-block-title">提示</p> <p>对于构建配置<code>configs.serverOpt</code>和启动配置<code>options</code>，我们将在<a href="#%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B">构建过程</a>一节中进行详细讨论。</p></div> <p>通常，我们在执行<code>start()</code>时使用<strong>回调函数</strong>处理Web服务的启动结果：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>serviceCore<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果error为null则表示Web服务启动成功</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Web服务启动失败</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">服务启动失败: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>error<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// Web服务启动成功</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'服务启动成功'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><strong>需要注意的是，<code>start()</code>执行成功后将会变更ServiceCore为启动状态，仅允许在关闭状态执行的操作将被拒绝执行：</strong></p> <ul><li><a href="#%E5%85%A8%E5%B1%80%E6%8B%A6%E6%88%AA%E5%99%A8">设置全局拦截器</a></li> <li><a href="#%E9%94%99%E8%AF%AF%E6%8B%A6%E6%88%AA%E5%99%A8">设置错误拦截器</a></li> <li><a href="#%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B">自定义构建过程</a></li></ul> <h2 id="设置请求路径"><a href="#设置请求路径" class="header-anchor">#</a> 设置请求路径</h2> <p>处理特定请求路径的客户端请求需要结合<a href="/guide/request-handler.html">Handler</a>进行。<strong>Handler</strong>有独立于<strong>ServiceCore</strong>的<a href="/guide/request-handler.html#处理流程">生命周期和处理流程</a>。</p> <p>客户端请求经过<strong>全局中间件</strong>管道后，将进入与请求路径匹配的<strong>Handler</strong>中执行后续处理。</p> <p><strong>我们实现一个Handler至少需要：</strong></p> <ul><li>指定请求路径规则</li> <li>指定请求方式（比如：GET、POST）对应的处理逻辑</li></ul> <p>因此，我们在<a href="/guide/request-handler.html">自定义Handler</a>时至少需要：</p> <ul><li><strong>实现一个继承自<code>Core.Handler</code>的类</strong></li> <li><strong>重写<code>getRoutePath</code>静态方法</strong>，指定请求路径规则</li> <li><strong>重写<code>[METHOD]Handler</code>实例方法</strong>，指定请求方式对应的处理逻辑</li></ul> <div class="custom-block warning"><p class="custom-block-title">注意</p> <p><strong>指定请求路径规则时，需要重写Handler中的静态方法，即<code>static getRoutePath()</code>；而实现某个请求方式的处理逻辑时重写的<code>[METHOD]Handler</code>是实例方法。</strong></p> <p>另外，<strong><code>[METHOD]Handler</code>不是实际重写的方法名，只是Handler Method的代称</strong>，比如：期望处理客户端POST请求时，需要重写<strong>Handler</strong>中的<strong>实例方法</strong><code>postHandler</code>。</p></div> <hr> <p>接下来，让我们来实现Hello World Handler：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">HelloWorldHandler</span> <span class="token keyword">extends</span> <span class="token class-name">Core<span class="token punctuation">.</span>Handler</span> <span class="token punctuation">{</span>
  <span class="token comment">// 指定请求路径规则</span>
  <span class="token keyword">static</span> <span class="token function">getRoutePath</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">'/HelloWorld.do'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 指定get请求处理</span>
  <span class="token function">getHandler</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">next</span><span class="token punctuation">(</span><span class="token string">'Hello World'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>需要注意的是，<strong>Handler必须绑定至ServiceCore才能生效。</strong></p> <p>所以，我们还应该使用<strong>ServiceCore</strong>的实例方法<code>bind()</code>将<strong>Handler</strong>与<strong>ServiceCore</strong>绑定：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 实现Hello World Handler</span>
<span class="token keyword">class</span> <span class="token class-name">HelloWorldHandler</span> <span class="token keyword">extends</span> <span class="token class-name">Core<span class="token punctuation">.</span>Handler</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>

<span class="token comment">// 创建ServiceCore</span>
<span class="token keyword">const</span> serviceCore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Core<span class="token punctuation">.</span>ServiceCore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 绑定ServiceCore和Handler</span>
<span class="token function">serviceCore</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token punctuation">[</span>HelloWorldHandler<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 启动ServiceCore</span>
serviceCore<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><strong>最后，我们使用浏览器打开<code>http://localhost:3000/HelloWorld.do</code>就可以检查实现成果啦！</strong></p> <div class="custom-block danger"><p class="custom-block-title">注意</p> <p><strong>ServiceCore实例仅允许在处于关闭状态时执行<code>bind()</code>动作，且多次执行<code>bind()</code>时将只保留最后一次绑定的Handler。</strong></p></div> <h2 id="构建过程"><a href="#构建过程" class="header-anchor">#</a> 构建过程</h2> <p><strong>ServiceCore</strong>执行实例方法<code>start()</code>时将触发<strong>Web服务</strong>的实际构建，<strong>我们可以通过修改实例属性<code>createServer</code>对构建过程进行定制。</strong></p> <div class="custom-block danger"><p class="custom-block-title">注意</p> <p><strong>ServiceCore实例仅允许在处于关闭状态时变更其<code>createServer</code>属性。</strong></p> <p>构建过程中需要包含<strong>构建Server</strong>和<strong>启动Server</strong>两个阶段。</p></div> <p><strong>ServiceCore</strong>的实例属性<code>createServer</code>应<strong>根据构建过程内实际逻辑的同步或异步使用<code>Function</code>或<code>AsyncFunction</code></strong>，其参数列表依次为：</p> <ul><li><p><strong><code>options</code></strong>：执行<code>start()</code>时指定的<strong>启动配置</strong>。</p></li> <li><p><strong><code>app</code></strong>：<strong>ServiceCore</strong>自动构建的<strong>Express实例</strong>。</p></li> <li><p><strong><code>configs</code></strong>：<strong>ServiceCore</strong>实例化时指定的构造参数。</p> <blockquote><p><strong>ServiceCore在实例化过程中将自动对构造参数中指定的配置进行校正。因此可能与创建ServiceCore时实际指定的构造参数有差异。</strong></p></blockquote></li> <li><p><strong><code>callBack</code></strong>：回调函数，参数列表为<code>(error, detail)</code>。</p> <blockquote><p><strong>ServiceCore将根据此函数回调的信息对构建结果进行仲裁，当回调的<code>error</code>为<code>null</code>时表示构建成功，此时ServiceCore将被变更为启动状态。</strong></p></blockquote> <div class="custom-block tip"><p class="custom-block-title">说明</p> <p>我们可以在定制<strong>构建过程</strong>时，使用期望的<code>error</code>和<code>detail</code>调用<code>callBack</code>，以控制<strong>ServiceCore</strong>实例方法<code>start()</code>回调启动结果时的附加信息。</p> <p><strong>在默认的构建过程下，<code>detail</code>的结构为<code>{ app, server, serverType }</code>：</strong></p> <ul><li><strong><code>app</code></strong>：<strong>ServiceCore</strong>自动构建的<strong>Express实例</strong>。</li> <li><strong><code>server</code></strong>：支撑<strong>Web服务</strong>的Server实例。</li> <li><strong><code>serverType</code></strong>：<strong>Server实例</strong>的类型，为<code>'http'</code>或<code>'https'</code>。</li></ul></div></li></ul> <hr> <p>接下来，我们将结合默认构建过程的实现，来讨论创建<strong>ServiceCore</strong>时指定的<code>configs.serverOpt</code>和执行<code>start()</code>时指定的<code>options</code>的作用。</p> <p>默认的构建过程实现如下：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token parameter">options<span class="token punctuation">,</span> app<span class="token punctuation">,</span> configs<span class="token punctuation">,</span> callBack</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 参数处理</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> port<span class="token punctuation">,</span> serverOpt <span class="token punctuation">}</span> <span class="token operator">=</span> configs<span class="token punctuation">;</span>
  options <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> port <span class="token punctuation">}</span><span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 创建server</span>
  <span class="token keyword">let</span> server <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> serverType <span class="token operator">=</span> <span class="token string">'http'</span><span class="token punctuation">;</span>
  <span class="token comment">// 当指定了有效的ssl配置时 - 启动https服务器</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>serverOpt <span class="token operator">&amp;&amp;</span> serverOpt<span class="token punctuation">.</span>cert <span class="token operator">&amp;&amp;</span> serverOpt<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    server <span class="token operator">=</span> https<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span>serverOpt<span class="token punctuation">,</span> app<span class="token punctuation">)</span><span class="token punctuation">;</span>
    serverType <span class="token operator">=</span> <span class="token string">'https'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 未指定ssl或配置无效时 - 启动http服务器</span>
  <span class="token keyword">else</span> <span class="token punctuation">{</span>
    server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span>serverOpt<span class="token punctuation">,</span> app<span class="token punctuation">)</span><span class="token punctuation">;</span>
    serverType <span class="token operator">=</span> <span class="token string">'http'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 启动server</span>
  server<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">callBack</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  server<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'listening'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">callBack</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> app<span class="token punctuation">,</span> server<span class="token punctuation">,</span> serverType <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>因此，在创建<strong>ServiceCore</strong>时，如果指定了有效的<code>configs.serverOpt.key</code>和<code>configs.serverOpt.cert</code>，则在执行<code>start()</code>时将使用<code>https.createServer()</code>创建Server实例，否则使用<code>http.createServer()</code>。</p> <div class="custom-block tip"><p class="custom-block-title">提示</p> <p><strong><code>configs.serverOpt</code>将作为创建Server实例的配置参数；执行实例方法<code>start()</code>时指定的启动配置<code>options</code>将作为启动Server实例的配置参数。</strong></p> <p>具体配置项可以参照<a href="https://nodejs.org/en/docs/" target="_blank" rel="noopener noreferrer">NodeJS官方文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中<code>https.createServer()</code>、<code>http.createServer()</code>和<code>server.listen()</code>的相关描述。</p></div> <h2 id="tls-ssl"><a href="#tls-ssl" class="header-anchor">#</a> TLS/SSL</h2> <p>如果我们期望启动TLS/SSL模式的Web服务，只需在实例化<strong>ServiceCore</strong>时指定有效的<code>configs.serverOpt.key</code>和<code>configs.serverOpt.cert</code>即可。</p> <p>我们在<a href="#%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B">构建过程</a>一节已经了解到，默认的构建行为使用<code>https.createServer()</code>实现Web服务的TLS/SSL，因此：</p> <p><strong>我们可以通过指定证书和密钥文件路径的方式启动TLS/SSL模式的Web服务。</strong></p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token constant">SSL_KEY_PATH</span> <span class="token operator">=</span> <span class="token string">'./ssl.key'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token constant">SSL_CERT_PATH</span> <span class="token operator">=</span> <span class="token string">'./cert.pem'</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> serviceCore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Core<span class="token punctuation">.</span>ServiceCore</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  serverOpt<span class="token operator">:</span> <span class="token punctuation">{</span>
    key<span class="token operator">:</span> <span class="token constant">SSL_KEY_PATH</span><span class="token punctuation">,</span>
    cert<span class="token operator">:</span> <span class="token constant">SSL_CERT_PATH</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>通常，直接指定证书和密钥文件的路径具有很大的局限性（比如：打包导致文件路径产生偏移）。</p> <p><strong>我们可以使用将证书和密钥装入<code>Buffer</code>的形式进行规避：</strong></p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token constant">SSL_KEY_PATH</span> <span class="token operator">=</span> <span class="token string">'./ssl.key'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token constant">SSL_CERT_PATH</span> <span class="token operator">=</span> <span class="token string">'./cert.pem'</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> serviceCore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Core<span class="token punctuation">.</span>ServiceCore</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  serverOpt<span class="token operator">:</span> <span class="token punctuation">{</span> 
    key<span class="token operator">:</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span><span class="token constant">SSL_KEY_PATH</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    cert<span class="token operator">:</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span><span class="token constant">SSL_CERT_PATH</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h2 id="处理模型"><a href="#处理模型" class="header-anchor">#</a> 处理模型</h2> <p><img src="/images/%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.jpg" alt="请求处理模型"></p> <h2 id="全局拦截器"><a href="#全局拦截器" class="header-anchor">#</a> 全局拦截器</h2> <p>进入<strong>ServiceCore</strong>的所有客户端流量将被<strong>全局拦截器</strong>捕获并处理。<strong>ServiceCore</strong>将在业务层执行实例方法<code>start()</code>时，将<strong>全局拦截器</strong>使用<code>app.use()</code>挂载至Express中间件列表首位。</p> <p><strong>我们可以通过修改ServiceCore的实例属性<code>globalIntercaptor</code>以对全局拦截器行为进行定制。</strong></p> <div class="custom-block danger"><p class="custom-block-title">注意</p> <ul><li><p><strong>在全局拦截器逻辑结束后，务必使用<code>next()</code>分发处理流程至后续阶段。</strong></p></li> <li><p><strong>ServiceCore实例仅允许在处于关闭状态时变更其<code>globalIntercaptor</code>属性。</strong></p></li> <li><p><strong>ServiceCore将自动捕获全局拦截器根函数维度产生的异常，使之进入<a href="#%E9%94%99%E8%AF%AF%E6%8B%A6%E6%88%AA%E5%99%A8">错误拦截器</a>处理。</strong>（因此，推荐使用<code>async/await</code>执行异步动作以保证异常抛出）。</p></li></ul></div> <p><strong>ServiceCore</strong>的实例属性<code>globalIntercaptor</code>应<strong>根据全局拦截器内实际逻辑的同步或异步使用<code>Function</code>或<code>AsyncFunction</code></strong>，其参数列表依次为：</p> <ul><li><strong><code>req</code></strong>：客户端请求实例。</li> <li><strong><code>res</code></strong>：客户端返回实例。</li> <li><strong><code>next</code></strong>：Express中间件流程控制函数，使用方式可以参考<a href="http://expressjs.com/en/guide/using-middleware.html" target="_blank" rel="noopener noreferrer">Express官方文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中对于<code>next()</code>的描述。</li></ul> <p><strong>在全局拦截器中不包含异步逻辑时，我们通常指定为<code>Function</code>类型：</strong></p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 指定同步全局拦截器</span>
serviceCore<span class="token punctuation">.</span><span class="token function-variable function">globalIntercaptor</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 执行全局拦截器逻辑</span>
  <span class="token comment">// ...</span>
  <span class="token comment">// 拦截器逻辑结束后执行next()分发处理流程至下游链路</span>
  <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>当全局拦截器中包含异步逻辑时，推荐指定为<code>AsyncFunction</code>类型以使用<code>await</code>指令进行异步操作：</strong></p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 指定异步全局拦截器</span>
serviceCore<span class="token punctuation">.</span><span class="token function-variable function">globalIntercaptor</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 执行全局拦截器逻辑</span>
  <span class="token comment">// ...</span>
  <span class="token comment">// 拦截器逻辑结束后执行next()分发处理流程至下游链路</span>
  <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><hr> <p>接下来，我们将结合默认全局拦截器的实现，来讨论其对后续处理过程产生的影响。</p> <p>默认全局拦截器的实现如下：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token function">globalInterceptor</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> requestPath <span class="token operator">=</span> req<span class="token punctuation">.</span>path<span class="token punctuation">;</span>
  <span class="token keyword">const</span> routePathes <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_handlerMap<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> isHandlerBinded <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> routePathes<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> handlerRoutePath <span class="token operator">=</span> routePathes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>requestPath<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>baseRoutePath<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> requestPath<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>handlerRoutePath<span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token punctuation">(</span>isHandlerBinded <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token operator">!</span>isHandlerBinded <span class="token operator">&amp;&amp;</span> res<span class="token punctuation">.</span><span class="token function">status</span><span class="token punctuation">(</span><span class="token number">404</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>因此，<strong>如果客户端请求路径未能匹配到Handler，则认为请求无效直接返回404状态码，不再进入后续的<a href="#%E5%85%A8%E5%B1%80%E4%B8%AD%E9%97%B4%E4%BB%B6">全局中间件</a>和<a href="/guide/request-handler.html">Handler阶段</a>。</strong></p> <div class="custom-block warning"><p class="custom-block-title">注意</p> <p><strong>我们可能在<a href="#%E5%85%A8%E5%B1%80%E4%B8%AD%E9%97%B4%E4%BB%B6">全局中间件</a>中使用泛路径中间件（如：<code>express.static</code>），默认的全局拦截器行为可能导致请求无效</strong>。此类场景下，我们可以尝试：</p> <ul><li>将泛路径中间件变更至<strong>Handler</strong>维度。</li> <li>变更<strong>全局拦截器</strong>默认行为，放行相关请求。</li></ul></div> <h2 id="全局中间件"><a href="#全局中间件" class="header-anchor">#</a> 全局中间件</h2> <p>我们把在<a href="#%E5%85%A8%E5%B1%80%E6%8B%A6%E6%88%AA%E5%99%A8">全局拦截器</a>中被放行的客户端请求称为<strong>有效请求</strong>，作用于有效请求的中间件便是<strong>全局中间件</strong>。</p> <div class="custom-block tip"><p class="custom-block-title">提示</p> <p><strong>全局中间件依赖于Express中间件系统实现，因此兼容Express生态且不支持动态中间件行为。</strong></p> <p>对于<strong>作用于特定请求路径的中间件</strong>，我们可以在<a href="/guide/request-handler.html">自定义Handler</a>时根据客户端请求的实际上下文（比如：请求参数）：</p> <ul><li><strong>动态指定中间件列表</strong></li> <li><strong>控制中间件执行规则</strong>（比如：跳过执行）</li></ul></div> <p><strong>全局中间件</strong>由创建<strong>ServiceCore</strong>时的构造参数<code>configs.middlewares</code>配置项指定：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> serviceCore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Core<span class="token punctuation">.</span>ServiceCore</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  middlewares<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><hr> <p><strong>ServiceCore</strong>在业务层执行实例方法<code>start()</code>时，当挂载<strong>全局拦截器</strong>完成后，将迭代构造参数<code>configs.middlewares</code>内的中间件，依次使用<code>app.use()</code>挂载至Express中间件列表。</p> <p>因此，我们可以直接使用Express生态的中间件作为<strong>全局中间件</strong>：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> bodyParser <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'body-parser'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 创建body-parser中间件</span>
<span class="token keyword">const</span> jsonParser <span class="token operator">=</span> bodyParser<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">{</span> limit<span class="token operator">:</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> urlEncodedParser <span class="token operator">=</span> bodyParser<span class="token punctuation">.</span><span class="token function">urlencoded</span><span class="token punctuation">(</span><span class="token punctuation">{</span> limit<span class="token operator">:</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">,</span> extended<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 创建ServiceCore并启动</span>
<span class="token keyword">const</span> serviceCore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Core<span class="token punctuation">.</span>ServiceCore</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  middlewares<span class="token operator">:</span> <span class="token punctuation">[</span>jsonParser<span class="token punctuation">,</span> urlEncodedParser<span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
serviceCore<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>需要注意的是，<strong>全局中间件不支持动态中间件</strong>。在一些<strong>全局中间件</strong>逻辑控制的场景中，我们可以使用<strong>Middleware Wrapper</strong>实现。</p> <p>接下来，我们将实现一个根据<code>body-parser</code>解析结果进行自定义处理的🌰，解析异常时不再向客户端抛出500状态码，而是使用200状态码向客户端返回异常信息：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> bodyParser <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'body-parser'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> jsonParser <span class="token operator">=</span> bodyParser<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">{</span> limit<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 对原始中间件进行包装,修改默认逻辑</span>
<span class="token keyword">const</span> <span class="token function-variable function">jsonParserWrapper</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">jsonParser</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> res<span class="token punctuation">.</span><span class="token function">status</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>error<span class="token punctuation">.</span>message<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 创建ServiceCore并启动</span>
<span class="token keyword">const</span> serviceCore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Core<span class="token punctuation">.</span>ServiceCore</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  middlewares<span class="token operator">:</span> <span class="token punctuation">[</span>jsonParserWrapper<span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
serviceCore<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="错误拦截器"><a href="#错误拦截器" class="header-anchor">#</a> 错误拦截器</h2> <p><strong>ServiceCore</strong>引入了<strong>错误拦截器</strong>用于收口请求处理过程中产生的异常。<strong>ServiceCore</strong>在业务层执行实例方法<code>start()</code>时，当挂载<strong>全局拦截器</strong>和<strong>全局中间件</strong>完成后，将<strong>错误拦截器</strong>使用<code>app.use()</code>挂载至Express中间件列表。</p> <div class="custom-block tip"><p class="custom-block-title">提示</p> <p><strong>错误拦截器</strong>本质上是一个位于Express中间件列表的末位的<strong>标准错误中间件</strong>，将捕获到以下类型的异常：</p> <ul><li><a href="#%E5%85%A8%E5%B1%80%E6%8B%A6%E6%88%AA%E5%99%A8">全局拦截器</a>执行过程中产生的异常</li> <li><a href="#%E5%85%A8%E5%B1%80%E4%B8%AD%E9%97%B4%E4%BB%B6">全局中间件</a>执行过程中产生的异常</li> <li><a href="/guide/request-handler.html#统一错误处理">Handler统一错误处理</a>执行过程中产生的异常</li></ul></div> <p>默认的<strong>错误拦截器</strong>将直接向客户端返回500状态码（即：执行<code>res.status(500).end()</code>），<strong>我们可以通过修改ServiceCore的实例属性<code>errorIntercaptor</code>以对错误拦截器逻辑进行定制。</strong></p> <div class="custom-block danger"><p class="custom-block-title">注意</p> <p><strong>ServiceCore实例仅允许在处于关闭状态时变更其<code>errorIntercaptor</code>属性。</strong></p> <p>另外，<strong>ServiceCore</strong>将自动包装<strong>错误拦截器</strong>为<strong>Express标准错误中间件</strong>。因此，我们在设置<strong>错误拦截器</strong>时，函数签名按需指定即可，<strong>无需严格保持<code>(error, req, res, next)</code>。</strong></p></div> <p><strong>ServiceCore</strong>的实例属性<code>errorIntercaptor</code>应<strong>根据错误拦截器内实际逻辑的同步或异步使用<code>Function</code>或<code>AsyncFunction</code></strong>，其参数列表依次为：</p> <ul><li><strong><code>error</code></strong>：未被捕获的异常。</li> <li><strong><code>req</code></strong>：客户端请求实例。</li> <li><strong><code>res</code></strong>：客户端返回实例。</li> <li><strong><code>next</code></strong>：Express中间件流程控制函数，使用方式可以参考<a href="https://expressjs.com/en/guide/error-handling.html#error-handling" target="_blank" rel="noopener noreferrer">Express官方文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中对于<code>next()</code>的描述。</li></ul> <p><strong>在错误拦截器中不包含异步逻辑时，我们通常指定为<code>Function</code>类型：</strong></p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 指定同步错误拦截器</span>
serviceCore<span class="token punctuation">.</span><span class="token function-variable function">errorIntercaptor</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">error<span class="token punctuation">,</span> req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 执行错误拦截器逻辑</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>当错误拦截器中包含异步逻辑时，推荐指定为<code>AsyncFunction</code>类型以使用<code>await</code>指令进行异步操作：</strong></p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 指定异步全局拦截器</span>
serviceCore<span class="token punctuation">.</span><span class="token function-variable function">globalIntercaptor</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">error<span class="token punctuation">,</span> req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 执行全局拦截器逻辑</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><hr> <p>当然，<strong>错误拦截器的执行过程中也可能产生异常，默认将触发Express的异常处理逻辑。</strong></p> <p>对于此类异常，我们通常在自定义<a href="#%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B">构建过程</a>时向<strong>Express实例</strong>中注入兜底<strong>Express错误处理中间件</strong>：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> serviceCore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Core<span class="token punctuation">.</span>serviceCore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> nativeCreateServer <span class="token operator">=</span> serviceCore<span class="token punctuation">.</span>_createServer<span class="token punctuation">;</span>
serviceCore<span class="token punctuation">.</span><span class="token function-variable function">createServer</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">options<span class="token punctuation">,</span> app<span class="token punctuation">,</span> configs<span class="token punctuation">,</span> callBack</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 注入兜底错误处理中间件(逻辑应保持简单以降低异常产生概率)</span>
  app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">error<span class="token punctuation">,</span> req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    res<span class="token punctuation">.</span><span class="token function">status</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>error<span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">nativeCreateServer</span><span class="token punctuation">(</span>options<span class="token punctuation">,</span> app<span class="token punctuation">,</span> configs<span class="token punctuation">,</span> callBack<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="日志收集"><a href="#日志收集" class="header-anchor">#</a> 日志收集</h2> <p>我们可以通过<strong>ServiceCore</strong>的实例属性<code>logger</code>指定其使用的<strong>日志收集工具</strong>。在内部实现上，<strong>ServiceCore</strong>将调用<code>this.logger.log(level, funcName, message)</code>输出其内部运行日志。</p> <p>通常，我们使用Corejs内置的<a href="/guide/logger-introduce.html#日期输出器">日期输出器</a>作为<strong>ServiceCore</strong>的<strong>日志收集工具</strong>：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> serviceCore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Core<span class="token punctuation">.</span>ServiceCore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 指定ServiceCore使用DateLogger进行日志收集</span>
serviceCore<span class="token punctuation">.</span>logger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Core<span class="token punctuation">.</span>DateLogger</span><span class="token punctuation">(</span><span class="token punctuation">{</span> filePrefix<span class="token operator">:</span> <span class="token string">'ServiceCore'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="custom-block tip"><p class="custom-block-title">提示</p> <p>Corejs内置的<strong>日期输出器</strong>将同一日期周期内产生的日志归档至一个文件（组），且支持自动清理和文件分割。</p></div> <hr> <p><strong>ServiceCore内部运行日志的输出等级、方法名和文案存储在<code>Core.Macros</code>和<code>Core.Messages</code>中，我们可以通过提前修改这些宏变量的方式实现日志内容定制（比如：日志国际化）。</strong></p> <ul><li><p><code>level</code>：日志输出等级</p> <div class="custom-block tip"><p class="custom-block-title">提示</p> <p>日志输出等级存储在<code>Core.Macros</code>中。</p></div> <table><thead><tr><th style="text-align:left;">宏名称</th> <th style="text-align:left;">描述</th> <th style="text-align:left;">默认值</th></tr></thead> <tbody><tr><td style="text-align:left;"><code>SERVICE_CORE_INFOS_LOG_LEVEL</code></td> <td style="text-align:left;">信息日志等级</td> <td style="text-align:left;"><code>'infos'</code></td></tr> <tr><td style="text-align:left;"><code>SERVICE_CORE_WARNS_LOG_LEVEL</code></td> <td style="text-align:left;">警告日志等级</td> <td style="text-align:left;"><code>'warns'</code></td></tr> <tr><td style="text-align:left;"><code>SERVICE_CORE_ERROR_LOG_LEVEL</code></td> <td style="text-align:left;">错误日志等级</td> <td style="text-align:left;"><code>'error'</code></td></tr></tbody></table></li> <li><p><code>funcName</code>：调用方法名</p> <div class="custom-block tip"><p class="custom-block-title">提示</p> <p>调用方法名存储在<code>Core.Messages</code>中。</p></div> <table><thead><tr><th style="text-align:left;">宏名称</th> <th style="text-align:left;">默认值</th></tr></thead> <tbody><tr><td style="text-align:left;"><code>SERVICE_CORE_FUNCNAME_LOG</code></td> <td style="text-align:left;"><code>'服务核心'</code></td></tr></tbody></table></li> <li><p><code>message</code>：日志文案内容</p> <div class="custom-block tip"><p class="custom-block-title">提示</p> <p>日志文案内容存储在<code>Core.Messages</code>中。</p> <p>定制日志文案内容时可以使用<code>${VAR_NAME}</code>的形式引用<strong>内置变量名</strong>以获取特征信息。</p> <blockquote><p><strong>比如：我们可以使用<code>'当前状态下无法执行操作:[${funcName}]'</code>引用内置变量名为<code>'funcName'</code>中的信息。</strong></p></blockquote></div> <table><thead><tr><th style="text-align:left;">宏名称</th> <th style="text-align:left;">描述</th> <th style="text-align:left;">内置变量名</th> <th style="text-align:left;">输出等级</th></tr></thead> <tbody><tr><td style="text-align:left;"><code>SERVICE_CORE_MESSAGE_INVALID_STATE</code></td> <td style="text-align:left;">当前状态下不允许执行操作</td> <td style="text-align:left;"><code>funcName</code>：操作方法名</td> <td style="text-align:left;"><code>SERVICE_CORE_WARNS_LOG_LEVEL</code></td></tr> <tr><td style="text-align:left;"><code>SERVICE_CORE_MESSAGE_INVALID_HANDLER</code></td> <td style="text-align:left;">待绑定的Handler类型无效</td> <td style="text-align:left;"><code>index</code>：Handler位于绑定列表的索引</td> <td style="text-align:left;"><code>SERVICE_CORE_WARNS_LOG_LEVEL</code></td></tr> <tr><td style="text-align:left;"><code>SERVICE_CORE_MESSAGE_INVALID_ROUTE_PATH</code></td> <td style="text-align:left;">待绑定的Handler请求路径无效</td> <td style="text-align:left;"><code>routePath</code>：Handler的请求路径</td> <td style="text-align:left;"><code>SERVICE_CORE_WARNS_LOG_LEVEL</code></td></tr> <tr><td style="text-align:left;"><code>SERVICE_CORE_MESSAGE_INVALID_PARAM_TYPE</code></td> <td style="text-align:left;">设置全局拦截器/错误拦截器/构建过程时参数无效</td> <td style="text-align:left;">无</td> <td style="text-align:left;">抛出异常，不产生日志</td></tr> <tr><td style="text-align:left;"><code>SERVICE_CORE_MESSAGE_SUCCESS_BIND_HANDLER</code></td> <td style="text-align:left;">成功绑定Handler</td> <td style="text-align:left;"><code>routePath</code>：Handler的请求路径</td> <td style="text-align:left;"><code>SERVICE_CORE_INFOS_LOG_LEVEL</code></td></tr> <tr><td style="text-align:left;"><code>SERVICE_CORE_MESSAGE_SUCCESS_START_SERVER</code></td> <td style="text-align:left;">ServiceCore启动成功</td> <td style="text-align:left;"><code>serverType</code>：ServiceCore的服务类型；<code>baseRoutePath</code>：基础请求路径</td> <td style="text-align:left;"><code>SERVICE_CORE_INFOS_LOG_LEVEL</code></td></tr> <tr><td style="text-align:left;"><code>SERVICE_CORE_MESSAGE_FAILURE_START_SERVER</code></td> <td style="text-align:left;">ServiceCore启动失败</td> <td style="text-align:left;"><code>error</code>：启动失败的原因</td> <td style="text-align:left;"><code>SERVICE_CORE_ERROR_LOG_LEVEL</code></td></tr></tbody></table></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/guide/getting-started.html" class="prev">
        快速上手
      </a></span> <span class="next"><a href="/guide/request-handler.html">
        请求处理
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.3dfa1ee5.js" defer></script><script src="/assets/js/2.6fef8c05.js" defer></script><script src="/assets/js/20.9002e28b.js" defer></script>
  </body>
</html>
